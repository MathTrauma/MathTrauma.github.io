
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/trauma.css">
    <title>MathTrauma</title>

    <!-- Prism.js 코드 하이라이팅 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>

    <!-- 필요한 언어 추가 (원하는 것만) -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-c.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-cpp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-glsl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-hlsl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-csharp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.min.js"></script>

    <!-- MathJax (LaTeX 수식) -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body class="blog-page">
    <header class="blog-header">
        <h1>MathTrauma Blog</h1>
        <p>보나마나</p>
    </header>
<div class="article-shell">
    <aside class="toc">
        <h4>목차</h4>
        <ul>
            <li><a href="#top">맨 위로</a></li>
        </ul>
    </aside>
    
    <main>
        <article class="article-body">
            <h1>[C++] Container 1 : vector, deque  - Adapter : queue, stack</h1>
            <h1>[C++] Container 1 : vector, deque  - Adapter : queue, stack</h1>
<p>container 들의 모든 멤버들을 한꺼번에 열거하는 것은 경험상 별 도움이 안된다. </p>
<p>많은 요소들을 가진 저장소를 어떻게 이용할 것인가에 집중해보자.</p>
<h4><strong>⚙️</strong>  <strong>모든 컨테이너에 공통되는 것부터</strong></h4>
<p>1-1. 저장소이니 얼마나 많이 저장하고 있는가를 알고 싶다.  -&gt; container.size( )</p>
<p>1-2. 혹시 비어있나? -&gt; container.empty( );</p>
<h3>1. vector 와 deque</h3>
<p>vector와 deque 모두 순차 접근을 기본으로 한다. 순차 접근 컨테이너를 둘로 만든 이유는 다음과 같다.</p>
<p>vector는 대충 배열을 이용한다고 생각하면 되는데, 알다시피 배열은 앞 부분의 원소를 추가하는데 비용이 많이 든다.</p>
<p>그래서 선두에 추가, 삭제가 잦은 상황에 더 효율적으로 대응하기 위한 container가 deque이다.</p>
<p>구현 방식은 다양할 수 있겠지만 <strong>중요한 것은 가장 앞과 뒤에서만 추가, 삭제가 일어난다는 점</strong>이다.</p>
<p>2-1. 선두 원소를 알고 싶다. =&gt; container.front( )  </p>
<p>2-2. 후미 원소를 알고 싶다. =&gt; container.back( )</p>
<p>3-1. 선두에 원소를 추가하고 싶다. =&gt; container.push_front( )</p>
<p>3-2. 선두의 원소를 제거하고 싶다. =&gt; container.pop_front( )</p>
<p>4-1. 후미에 원소를 추가하고 싶다. =&gt; container.push_back( )</p>
<p>4-2. 끝부분의 원소를 제거하련다. =&gt; container.pop_back( ) </p>
<p>선두와 후미가 주된 작업 지점이지만 내용물들을 훑어 보고 싶을 수 있다. </p>
<p>5. iterator :  c.begin( ), c.end( ), c.rbegin( ), c.rend( ) </p>
<p>6. 다 봤으니 없애 버리자. =&gt; container.erase( )  *주의 : 메모리를 해제하는 것은 아니고 내용물을 지운다.</p>
<p>이 정도면 충분하지 않을까? 이 외에도 많은 메서드들이 있지만 위의 내용들에 익숙해지고 나서 공부하자.</p>
<h3>2. queue, priority_queue 그리고 stack</h3>
<p><queue> 헤더의 queue, priority_queue 와 <stack> 헤더의 stack 은 다른 container 에 저장된 요소들에 추가적인 interface 를 제공하기 때문에 <strong>adapter</strong> 라고 부른다.</p>
<p>예를 들어, queue의 정의를 보면 다음과 같다.</p>
<p><strong>template&lt;class T, class Container=deque<T>&gt; class queue;</strong></p>
<p>여기서 알 수 있듯이 기본적으로는 deque 컨테이너를 이용해서 저장하고 있다. </p>
<p>내막을 정확히 알아야 하는 것은 아니고 사용법만 익히면 충분하니 깊게 파고 들지는 말자.</p>
<h4>(1) 용도</h4>
<p>💡 queue 는 원소 들어온 순서대로 배출하기 위해 사용된다.(FIFO : First-In-First-Out)</p>
<p>- 그렇다면 앞, 뒤 방향이 중요할까? =&gt; que.push( ), que.pop( ) </p>
<p>[deque  에서는 push_back( ), push_front( ) 로 방향을 구분했지만 지금을 그럴 필요가 없다!]</p>
<p><strong>- 다음 차례는 누구냐? =&gt; que.front( )</strong></p>
<p>💡 priority_queue 는 **&#39;자료형의 대소 관계&#39;**를 이용해서 큰 쪽을 top 에 둔다. (그냥 대소 관계가 아니라 자료형의 대소 관계라 했다. 부등호를 정의하기 나름임에 주의! 참고로 이 친구는 base container 가 vector이다.) </p>
<p>- 앞, 뒤 방향이 중요하지 않은 것은 마찬가지. =&gt; pq.push( ), pq.pop( ) </p>
<p><strong>- 제일 쎈 놈이 누구냐? =&gt; pq.top( )</strong></p>
<p>💡 stack 은 늦게 들어온 요소가 먼저 나간다. (이를 LIFO : Last-In-First-Out 라 표현한다.)</p>
<p>- 앞, 뒤 방향이 중요하지 않은 것은 마찬가지. =&gt; st.push( ), st.pop( ) </p>
<p><strong>- 마지막에 누가 왔었지? =&gt; st.top( )</strong></p>
<p><strong>이 글은 여기까지. 여기서 다룬 것만으로도 어지간한 상황에서는 충분할 것이다.</strong></p>

        </article>
    </main>
    
    <aside class="article-aside">
        <div class="panel">
            <h4>카테고리</h4>
            <p><a href="index.html">← algorithm</a></p>
        </div>
    </aside>
</div>
<footer>
    <p>&copy; 2025 MathTrauma. All rights reserved.</p>
</footer>
</body>

</html>
