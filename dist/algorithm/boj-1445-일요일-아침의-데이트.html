
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/trauma.css">
    <title>MathTrauma</title>

    <!-- Prism.js 코드 하이라이팅 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>

    <!-- 필요한 언어 추가 (원하는 것만) -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-c.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-cpp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-glsl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-hlsl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-csharp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.min.js"></script>

    <!-- MathJax (LaTeX 수식) -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body class="blog-page">
    <header class="blog-header">
        <h1>MathTrauma Blog</h1>
        <p>보나마나</p>
    </header>
<div class="article-shell">
    <aside class="toc">
        <h4>목차</h4>
        <ul>
            <li><a href="#top">맨 위로</a></li>
        </ul>
    </aside>
    
    <main>
        <article class="article-body">
            <h1>BOJ 1445 일요일 아침의 데이트</h1>
            <h1>BOJ 1445 일요일 아침의 데이트</h1>
<p>문제 링크 : <a href="https://www.acmicpc.net/problem/1445">https://www.acmicpc.net/problem/1445</a></p>
<p>1445번: 일요일 아침의 데이트</p>
<p>첫째 줄에 숲의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 3보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 숲의 지도가 주어진다. 숲의 지도는 S, F, g, . 만으로 이루어져 있</p>
<p><a href="http://www.acmicpc.net">www.acmicpc.net</a></p>
<p>통상의 거리(비용)을 순서쌍 비용으로 바꾸면 된다.</p>
<p>즉, 거리를 </p>
<p> pair&lt;int,int&gt;(지나온 g의 개수, g 인접한 곳을 지난 횟수)</p>
<p>로 두면 평범한 최단 경로 문제가 된다.</p>
<p>하지만, 문제의 조건을 여러 번 잘못 읽었다. </p>
<p>시작, 마지막 지점은 쓰레기 옆이어도 count 하지 않는다는 조건도 한참 뒤에서야 봤다.</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;

struct info{
    pair&lt;int,int&gt; cst; 
    int y,x;
    bool operator&lt;(const info &amp;rhs) const {
        return cst &gt; rhs.cst;
    }
};

int dy[]={0,1,0,-1}, dx[]={1,0,-1,0};
int h,w;
int sy, sx, ey, ex;

pair&lt;int,int&gt; Cst[51][51]; 
int Near[51][51];
char Map[51][51];

void count_near(){
    for(int i=0;i&lt;h;i++){
        for(int j=0;j&lt;w;j++){
            if(Map[i][j]!=&#39;.&#39;)continue;
            for(int k=0;k&lt;4;k++){
                int ni=i+dy[k], nj=j+dx[k];
                if(ni&lt;0 || ni&gt;=h || nj&lt;0 || nj&gt;=w) continue;
                if(Map[ni][nj]==&#39;g&#39;) {
                    Near[i][j]=1;
                    break;
                }
            }
        }
    }
}

pair&lt;int,int&gt; find_path(){
    for(int i=0;i&lt;h;i++){
        for(int j=0;j&lt;w;j++){
            Cst[i][j]={INT_MAX, INT_MAX};
        }
    }
    
    Cst[sy][sx]={0,Near[sy][sx]};
    priority_queue&lt;info&gt; pq;
    pq.push({Cst[sy][sx], sy, sx});
    
    while(!pq.empty()){
        info tInfo=pq.top();
        pq.pop();
        
        int cy=tInfo.y, cx=tInfo.x;     
        if(cy==ey &amp;&amp; cx==ex) break;
        
        if(Cst[cy][cx]&lt;tInfo.cst) continue;
        
        for(int i=0;i&lt;4;i++){
            int ny=cy+dy[i], nx=cx+dx[i];
            if(ny&lt;0 || ny&gt;=h || nx&lt;0 || nx&gt;=w) continue;
            
            int gg=Map[ny][nx]==&#39;g&#39;?1:0;
            int gn=Near[ny][nx];
            
            if(Cst[ny][nx] &gt; pair&lt;int,int&gt;(tInfo.cst.first+gg, tInfo.cst.second+gn) ){
                Cst[ny][nx]={tInfo.cst.first+gg, tInfo.cst.second+gn};
                pq.push({Cst[ny][nx], ny, nx});
            }
        }
    }
    
    return Cst[ey][ex];
}

int main(){
    scanf(&quot;%d%d&quot;,&amp;h,&amp;w);
    
    for(int i=0;i&lt;h;i++){
        for(int j=0;j&lt;w;j++){
            scanf(&quot; %c&quot;, &amp;Map[i][j]);
            if(Map[i][j]==&#39;S&#39;) {
                sy=i, sx=j;
            } else if(Map[i][j]==&#39;F&#39;){
                ey=i, ex=j;
            }
        }
    }
    
    count_near();
    
    pair&lt;int,int&gt; res=find_path();
    
    printf(&quot;%d %d\n&quot;, res.first, res.second);
}
</code></pre>

        </article>
    </main>
    
    <aside class="article-aside">
        <div class="panel">
            <h4>카테고리</h4>
            <p><a href="index.html">← algorithm</a></p>
        </div>
    </aside>
</div>
<footer>
    <p>&copy; 2025 MathTrauma. All rights reserved.</p>
</footer>
</body>

</html>
