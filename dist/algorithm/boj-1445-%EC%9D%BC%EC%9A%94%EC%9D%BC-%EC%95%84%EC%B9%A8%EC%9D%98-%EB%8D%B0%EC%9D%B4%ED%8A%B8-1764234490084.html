
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/trauma.css">
    <title>MathTrauma</title>

    <!-- Prism.js 코드 하이라이팅 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>

    <!-- 필요한 언어 추가 (원하는 것만) -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-c.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-cpp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-glsl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-hlsl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-csharp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.min.js"></script>

    <!-- MathJax (LaTeX 수식) -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body class="blog-page">
    <header class="blog-header">
        <h1>MathTrauma Blog</h1>
        <p>보나마나</p>
    </header>
<main class="blog-container">
<article class="blog-post">
<h1>BOJ 1445 일요일 아침의 데이트</h1>
<h1>BOJ 1445 일요일 아침의 데이트</h1>
<p>문제 링크 : <a href="https://www.acmicpc.net/problem/1445">https://www.acmicpc.net/problem/1445</a></p>
<p>1445번: 일요일 아침의 데이트</p>
<p>첫째 줄에 숲의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 3보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 숲의 지도가 주어진다. 숲의 지도는 S, F, g, . 만으로 이루어져 있</p>
<p><a href="http://www.acmicpc.net">www.acmicpc.net</a></p>
<p>통상의 거리(비용)을 순서쌍 비용으로 바꾸면 된다.</p>
<p>즉, 거리를 </p>
<p> pair&lt;int,int&gt;(지나온 g의 개수, g 인접한 곳을 지난 횟수)</p>
<p>로 두면 평범한 최단 경로 문제가 된다.</p>
<p>하지만, 문제의 조건을 여러 번 잘못 읽었다. </p>
<p>시작, 마지막 지점은 쓰레기 옆이어도 count 하지 않는다는 조건도 한참 뒤에서야 봤다.</p>
<p>#include&lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>struct info{<br>    pair&lt;int,int&gt; cst;<br>    int y,x;<br>    bool operator&lt;(const info &amp;rhs) const {<br>        return cst &gt; rhs.cst;<br>    }<br>};</p>
<p>int dy[]={0,1,0,-1}, dx[]={1,0,-1,0};<br>int h,w;<br>int sy, sx, ey, ex;</p>
<p>pair&lt;int,int&gt; Cst[51][51];<br>int Near[51][51];<br>char Map[51][51];</p>
<p>void count_near(){<br>    for(int i=0;i&lt;h;i++){<br>        for(int j=0;j&lt;w;j++){<br>            if(Map[i][j]!=&#39;.&#39;)continue;<br>            for(int k=0;k&lt;4;k++){<br>                int ni=i+dy[k], nj=j+dx[k];<br>                if(ni&lt;0 || ni&gt;=h || nj&lt;0 || nj&gt;=w) continue;<br>                if(Map[ni][nj]==&#39;g&#39;) {<br>                    Near[i][j]=1;<br>                    break;<br>                }<br>            }<br>        }<br>    }<br>}</p>
<p>pair&lt;int,int&gt; find_path(){<br>    for(int i=0;i&lt;h;i++){<br>        for(int j=0;j&lt;w;j++){<br>            Cst[i][j]={INT_MAX, INT_MAX};<br>        }<br>    }</p>
<pre><code>Cst[sy][sx]={0,Near[sy][sx]};
priority_queue&lt;info&gt; pq;
pq.push({Cst[sy][sx], sy, sx});

while(!pq.empty()){
    info tInfo=pq.top();
    pq.pop();
    
    int cy=tInfo.y, cx=tInfo.x;     
    if(cy==ey &amp;&amp; cx==ex) break;
    
    if(Cst[cy][cx]&lt;tInfo.cst) continue;
    
    for(int i=0;i&lt;4;i++){
        int ny=cy+dy[i], nx=cx+dx[i];
        if(ny&lt;0 || ny&gt;=h || nx&lt;0 || nx&gt;=w) continue;
        
        int gg=Map[ny][nx]==&#39;g&#39;?1:0;
        int gn=Near[ny][nx];
        
        if(Cst[ny][nx] &gt; pair&lt;int,int&gt;(tInfo.cst.first+gg, tInfo.cst.second+gn) ){
            Cst[ny][nx]={tInfo.cst.first+gg, tInfo.cst.second+gn};
            pq.push({Cst[ny][nx], ny, nx});
        }
    }
}

return Cst[ey][ex];
</code></pre>
<p>}</p>
<p>int main(){<br>    scanf(&quot;%d%d&quot;,&amp;h,&amp;w);</p>
<pre><code>for(int i=0;i&lt;h;i++){
    for(int j=0;j&lt;w;j++){
        scanf(&quot; %c&quot;, &amp;Map[i][j]);
        if(Map[i][j]==&#39;S&#39;) {
            sy=i, sx=j;
        } else if(Map[i][j]==&#39;F&#39;){
            ey=i, ex=j;
        }
    }
}

count_near();

pair&lt;int,int&gt; res=find_path();

printf(&quot;%d %d\n&quot;, res.first, res.second);
</code></pre>
<p>}</p>

</article>
</main>
<footer>
    <p>&copy; 2025 MathTrauma. All rights reserved.</p>
</footer>
</body>

</html>
