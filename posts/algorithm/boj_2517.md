# BOJ 2517 달리기

문제 링크 : [https://www.acmicpc.net/problem/2517](https://www.acmicpc.net/problem/2517)

 [2517번: 달리기

첫째 줄에는 선수의 수를 의미하는 정수 N이 주어진다. N은 3 이상 500,000 이하이다. 이후 N개의 줄에는 정수가 한 줄에 하나씩 주어진다. 이 값들은 각 선수들의 평소 실력을 앞에서 달리고 있는

www.acmicpc.net](https://www.acmicpc.net/problem/2517)

입력값을 차례대로 입력받는다 가정.

이전 입력 값들 중 현재 입력받는 값보다 작은 값들의 누적 개수를 기록할 자료 구조가 필요.

펜윅 트리(Fenwick Tree) 를 사용하기로 한다.

### 펜위 트리 구조의 요약.

index 가 1부터 출발하는 Fenwick Tree 의 경우 약수인 최대의 \\(2^n\\) 개만큼 앞의 원소들의 합을 보관한다.

1 로 끝나면 약수인 2의 거듭제곱 중 최대는 \\(2^0\\)이고 하나의 값을 저장.

10 으로 끝나면 \\(2^1=2\\) 가 최대의 2의 거듭제곱 형태의 약수이고 2개의 합을 저장.

100 이면 4개 값의 합를 저장한다. (001, 010, 011, 100 의 네 개)

#### 1\. update

위의 관찰을 반대 방향에서 진행하면 001로 끝나면 010 , 100 등등을 갱신해야 한다. 

즉, 입력 index 가 주어지면 index 보다 크거나 같은 2의 거듭제곱들의 배수들을 차례로 갱신해야 한다.

\\\[2^k +2^k=2^{k+1}\\\] 

이므로 0 이 아닌 마지막 비트를 차례로 더해주면 원하는 결과를 얻는다.

#### 2\. sum

예를 들어 110(6)을 생각해보자. 1 번부터 6 번까지의 항의 합을 구해야 한다.

그런데 끝이 10이니 110 위치에는 101(5), 110(6) 번의 두 원소의 합을 가지고 있고 100은 1~4 번 항의 합을 가지고 있다. 

끝에서부터 1을 하나씩 제거하면서 합을 구하면 된다.

```Cpp
#include<bits/stdc++.h>

using namespace std;

int sz;
int arr[500010], cpy[500010], Bit[500010];

void upd(int p, int v) {
    for(; p<=sz; p+=p&-p) Bit[p]+=v; 
}

int qry(int p) {
    int ans=0;
    for(; p>0; p&=p-1) ans+=Bit[p];
    return ans;
}

int main() {
    scanf("%d", &sz);
    for(int i=1;i<=sz;i++){
        scanf("%d", arr+i);
        cpy[i]=arr[i];
    }
    
    sort(cpy, cpy+sz+1);
    
    for(int i=1;i<=sz;i++){
        int tmp=lower_bound(cpy, cpy+sz+1, arr[i])-cpy;
        printf("%d\n", i-qry(tmp));
        upd(tmp, 1);
    }
    
    return 0;
}
```