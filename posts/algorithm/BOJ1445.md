# BOJ 1445 일요일 아침의 데이트

문제 링크 : https://www.acmicpc.net/problem/1445

1445번: 일요일 아침의 데이트

첫째 줄에 숲의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 3보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 숲의 지도가 주어진다. 숲의 지도는 S, F, g, . 만으로 이루어져 있

www.acmicpc.net


통상의 거리(비용)을 순서쌍 비용으로 바꾸면 된다.

즉, 거리를 


 pair<int,int>(지나온 g의 개수, g 인접한 곳을 지난 횟수)


로 두면 평범한 최단 경로 문제가 된다.



하지만, 문제의 조건을 여러 번 잘못 읽었다. 

시작, 마지막 지점은 쓰레기 옆이어도 count 하지 않는다는 조건도 한참 뒤에서야 봤다.



#include<bits/stdc++.h>

using namespace std;

struct info{
    pair<int,int> cst; 
    int y,x;
    bool operator<(const info &rhs) const {
        return cst > rhs.cst;
    }
};

int dy[]={0,1,0,-1}, dx[]={1,0,-1,0};
int h,w;
int sy, sx, ey, ex;

pair<int,int> Cst[51][51]; 
int Near[51][51];
char Map[51][51];

void count_near(){
    for(int i=0;i<h;i++){
        for(int j=0;j<w;j++){
            if(Map[i][j]!='.')continue;
            for(int k=0;k<4;k++){
                int ni=i+dy[k], nj=j+dx[k];
                if(ni<0 || ni>=h || nj<0 || nj>=w) continue;
                if(Map[ni][nj]=='g') {
                    Near[i][j]=1;
                    break;
                }
            }
        }
    }
}

pair<int,int> find_path(){
    for(int i=0;i<h;i++){
        for(int j=0;j<w;j++){
            Cst[i][j]={INT_MAX, INT_MAX};
        }
    }
    
    Cst[sy][sx]={0,Near[sy][sx]};
    priority_queue<info> pq;
    pq.push({Cst[sy][sx], sy, sx});
    
    while(!pq.empty()){
        info tInfo=pq.top();
        pq.pop();
        
        int cy=tInfo.y, cx=tInfo.x;     
        if(cy==ey && cx==ex) break;
        
        if(Cst[cy][cx]<tInfo.cst) continue;
        
        for(int i=0;i<4;i++){
            int ny=cy+dy[i], nx=cx+dx[i];
            if(ny<0 || ny>=h || nx<0 || nx>=w) continue;
            
            int gg=Map[ny][nx]=='g'?1:0;
            int gn=Near[ny][nx];
            
            if(Cst[ny][nx] > pair<int,int>(tInfo.cst.first+gg, tInfo.cst.second+gn) ){
                Cst[ny][nx]={tInfo.cst.first+gg, tInfo.cst.second+gn};
                pq.push({Cst[ny][nx], ny, nx});
            }
        }
    }
    
    return Cst[ey][ex];
}

int main(){
    scanf("%d%d",&h,&w);
    
    for(int i=0;i<h;i++){
        for(int j=0;j<w;j++){
            scanf(" %c", &Map[i][j]);
            if(Map[i][j]=='S') {
                sy=i, sx=j;
            } else if(Map[i][j]=='F'){
                ey=i, ex=j;
            }
        }
    }
    
    count_near();
    
    pair<int,int> res=find_path();
    
    printf("%d %d\n", res.first, res.second);
}


