 문제 링크 : [https://www.acmicpc.net/problem/6549](https://www.acmicpc.net/problem/6549)

 [6549번: 히스토그램에서 가장 큰 직사각형

입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤

www.acmicpc.net](https://www.acmicpc.net/problem/6549)

배열 arr\[i\] 은  i=1 부터 시작하고,  구간\[i-1, i\] 에 세워진 기둥의 높이로 간주했다. 

넓이가 최대가 되는 직사각형의 밑변이 구간 \[L, R\] 이라고 가정해 보자.

이 구간에서 arr\[i\]의 값이 최소가 되는 것을 찾아야 한다. (  $ L<i \\le R $  )

모든 (L, R)의 순서쌍을 고려하는 것은 시간 복잡도가 $O(n^2)$ 일 것이니 곤란하다.  
그래서,





### 1\. 거꾸로 **각각의 i 에 대해, arr\[i\] 을 최소로 하는 구간을 찾는다.**

다음의 히스토그램을 보자.

[##_Image|kage@dRKeoU/btrR8o3q0eY/AAAAAAAAAAAAAAAAAAAAAM7eeHcR7fXACIFhCfj4uxgo8mBqupbNpWiKTmFfzqXB/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=6WbSLRzY0osvTBlb46UuvfClnRw%3D|CDM|1.3|{"originWidth":1920,"originHeight":1080,"style":"alignCenter","width":600,"height":338,"filename":"Untitled.001.png"}_##]

index=5 인 50의 높이를 가지는 직사각형을 중심으로 사고하자. 

왼쪽으로 차례로 확인해서 index=2 에서 최초로 50보다 낮은 높이 20 을 만난다.

오른쪽으로는 index=8 에서 40의 높이를 만난다.

결과를 표시하면 다음과 같다.

[##_Image|kage@Pn1qs/btrR8uJfZB6/AAAAAAAAAAAAAAAAAAAAADI6NJcWpsUNv3dJAd0Mqr-TKGditKMfKUB4e4ewiQto/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=nZNR2NDOhO0C6KMx2d98Op3Btvs%3D|CDM|1.3|{"originWidth":1920,"originHeight":1080,"style":"alignCenter","width":600,"height":338,"filename":"Untitled.002.png"}_##]

일반화해서 i 에 대해 정리하여 왼쪽 경계를 ml\[i\]라 하자.

index 를 i 에서 차례로 줄이면서 최초로 arr\[i\] > arr\[j\] 를 만족하는 j 를 찾으면  ml\[i\] 가 된다.

이 때, 다음의 조건들을 만족한다.

$$ j<i ,  arr\[j\] < arr\[i\] $$

이고

$$ j < k < i \\rightarrow arr\[k\] \\ge arr\[i\] $$

이다.

### 2\. 어떻게 $ O(n) $ 으로 ml 배열을 찾을 것인가? - Stack 을 사용해 보자.

dp를 사용해서도  $ O(n) $으로 배열 ml 을 채울 수 있지만 여기서는 stack 을 이용한다.

(우측 경계값들을 의미하는 배열 mr 역시 같은 방식으로 완성할 수 있다.)

각각의 i 에 대해서 매번 왼쪽으로 차례대로 모두 조사한다면 $ O(n^2) $ 를 면치 못 할 것이다.

앞선 index 들에서 조사한 결과를 재활용하기 위해 stack이 사용된다.

ml\[1\]에서 ml\[5\]까지를 구하는 과정을 슬라이드로 살펴보자.

(스택에 들어가는 것은 값이 아니고 index이지만 편의상 값을 그렸다.)

[##_ImageSlide|kage@czpFc3/btrSa7FB5lz/AAAAAAAAAAAAAAAAAAAAAFQ-E4hDZenzStl2RIcvsQqL1FxaFbeb_OnZdreYw2uO/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=MbhoXTjxBP0kCLgT%2FhUKz%2BrHA0I%3D,kage@kS0wD/btrR8J0wVEL/AAAAAAAAAAAAAAAAAAAAAKH63LkbhFe5ybFc3ZG1pJcIYvu544tIYyVcTurazr6R/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=1BgSJefTP6mkG%2BIWi0Gc0ISfIm4%3D,kage@b1ASKS/btrSahPjGfM/AAAAAAAAAAAAAAAAAAAAAGJV2b3_N_4rAk5NlKPdmTIBRhDiHCX80DtlZxulJw62/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=jHNoJcpQy0i2VbY09T5EdpxsNlk%3D,kage@bi4g5J/btrR9WYS2BL/AAAAAAAAAAAAAAAAAAAAAMM8IV1VBfYN8CoJkCWcHPYqLpsEI87zKH2KmTjaIw0u/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=2qiSRP6F4khRA3LSBdob3FnhaXg%3D,kage@ezYJ92/btrSa7r5UXx/AAAAAAAAAAAAAAAAAAAAAMM77WWUfJLcg4WYjZrLocer_0JfFUowb1ZTJR2jN7RJ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=Oij7ekhXRyLaOl41Jmpmh3IH7Tg%3D,kage@ONtW8/btrR8aqVAjA/AAAAAAAAAAAAAAAAAAAAAJbLH9iEP0f0F_4CPvWbxEEVXpHhL_Cf66aeJnc4w_bq/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=Vs6RNnOPQA4IdRbdEIIreTOQ5S8%3D,kage@bYbUgq/btrR9FQBJZh/AAAAAAAAAAAAAAAAAAAAAC-Z9JnqZtvghiKfOqw1H-e33yA-vFjTyDtGJvU3uvkD/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=L2wdpCFNPbZHpU02KC2C2mU399c%3D,kage@WfLv1/btrR9v8n6vf/AAAAAAAAAAAAAAAAAAAAAD0jhU2QFimKI-IMRjQBzIcdzHbhlK8-xURzDQJxF1JX/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1767193199&amp;allow_ip=&amp;allow_referer=&amp;signature=xTDSlMDLDe2OHlHmHHJzxF2Hj70%3D|alignCenter|data-origin-width="1920" data-origin-height="1080"|_##]

각 i 에 대해 $arr\[i\]$보다 큰 값을 가지는 index 는 스택 상단에서 모두 제거하고, i 를 스택에 넣는다.

제거의 정당성은 슬라이드에서 설명했고, 스택에 입력되는 자료는 n 개이므로 스택의 제거 동작도 n 을 넘지 않는다.

결국 $ O(n) $ 으로 ml을 완성할 수 있다.

### 3\. Code

위의 설명이면 딱히 추가할 것은 없다. 완성된 코드는 다음과 같다.


```Cpp
#include <bits/stdc++.h>

using namespace std;

using ll=long long;

ll arr[100001];
ll ml[100001], mr[100001];

int main() {
    while(1) {
        int n; scanf("%d", &n);
        if(!n) break;
        
        stack<int> st;
        for(int i=1;i<=n;i++){
            scanf("%lld", &arr[i]);
            while(st.size()) {
                int x=st.top();
                if(arr[x]<arr[i]) break;
                st.pop();             
            }
            
            if(st.empty()) ml[i]=0;
            else ml[i]=st.top();
            
            st.push(i);
        }
        
        st=stack<int>();
        for(int i=n;i>=1;i--) {
            while(st.size()) {
                int x=st.top();
                if(arr[x]<arr[i])break;
                st.pop();
            }
            
            if(st.empty()) mr[i]=n;
            else mr[i]=st.top()-1;
            
            st.push(i);
        }
        
        ll res=0;
        for(int i=1;i<=n;i++) {
            res=max(res, (mr[i]-ml[i])*arr[i]);
        }
        
        printf("%lld\n", res);
    }
}
```


시간을 손해보더라도 
좌우 분할로 작은 문제를 만들고 싶으면 다음 코드를 사용한다. $O(n\log n)$

```Cpp
#include<bits/stdc++.h>

using namespace std;
using ll=long long;

ll arr[100001];

ll solve(int tl, int tr){
    if(tl==tr) return arr[tl];
    
    int mid=tl+tr>>1;
    ll L=solve(tl, mid), R=solve(mid+1,tr);
    
    int l=mid, r=mid+1;
    ll current_height=min(arr[l], arr[r]);
    ll res=2*current_height;
    
    while(tl<l || r<tr) {
        ll p=-1, q=-1;
        if(tl<l) p=min(current_height, arr[l-1]);
        if(r<tr) q=min(current_height, arr[r+1]);
        
        if(p>q) {
            current_height=p;
            l--;
        } else {
            current_height=q;
            r++;
        }
        res=max(res, (ll)(r-l+1)*current_height);
    }
    return max(res, max(L,R));
}

int main(){
    while(1){
        int n; scanf("%d",&n);
        if(!n) break;
        for(int i=1;i<=n;i++) scanf("%lld", &arr[i]);
        printf("%lld\n", solve(1,n));
    }
}

```